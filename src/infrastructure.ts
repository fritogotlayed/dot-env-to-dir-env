const DOT_FILE = '.dot2dirrc';

export type DirSettings = {
  environment: string;
  includeLocal: boolean;
};

export class Infrastructure {
  static async safeReadEnvFile(
    filePath: string,
  ): Promise<Record<string, unknown> | null> {
    try {
      const data = await Deno.readTextFile(filePath);
      return data.split('\n').reduce((acc, line) => {
        const [key, ...value] = line.split('=');
        // if the line is empty or a comment, ignore it
        if (!line.trim() || line.trim().startsWith('#')) {
          return acc;
        }
        acc[key.trim()] = value.join('=').trim();
        return acc;
      }, {} as Record<string, unknown>);
    } catch (error) {
      if (error instanceof Deno.errors.NotFound) {
        return null;
      }
      throw error;
    }
  }

  static async safeWriteDotEnvFile(
    { dirPath, env, data }: {
      dirPath: string;
      env: string;
      data: Record<string, unknown>;
    },
  ): Promise<void> {
    const slug = env ? `and .env.${env} files` : 'file';
    const header =
      `# WARNING: Do not edit this file directly as it will be overwritten!
# This file is auto-generated by dot-env-to-dir-env. To update the contents of
# this file make adjustments to the .env ${slug} or adjust the
# current environment with the dot-env-to-dir-env CLI.`;

    await Deno.writeTextFile(
      `${dirPath}/.envrc`,
      `${header}\n${
        Object.entries(data)
          .map(([key, value]) => `export ${key}=${value}`)
          .join('\n')
      }`,
    );
  }

  static async getSettingsForPath(
    dirPath: string,
  ): Promise<DirSettings> {
    // Read the .dot2dirrc file if it exists to get the environment. If it does not exist,
    // use the default environment
    const dot2dirrcFile = `${dirPath}/${DOT_FILE}`;
    let fileData: string | null = null;
    try {
      fileData = await Deno.readTextFile(dot2dirrcFile);
    } catch (error) {
      if (error instanceof Deno.errors.NotFound) {
        return {
          environment: '',
          includeLocal: true,
        };
      }
      throw error;
    }

    try {
      return JSON.parse(fileData) as DirSettings;
    } catch {
      return {
        environment: fileData,
        includeLocal: true,
      };
    }
  }

  static async writeSettingsForPath(
    dirPath: string,
    settings: DirSettings,
  ): Promise<void> {
    // Write the settings file
    await Deno.writeTextFile(
      `${dirPath}/${DOT_FILE}`,
      JSON.stringify(settings),
    );
  }
}
