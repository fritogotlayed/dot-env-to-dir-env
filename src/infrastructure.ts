const DOT_FILE = '.dot2dirrc';

export type DirSettings = {
  environment: string;
  includeLocal: boolean;
  lastModified: Record<string, number | undefined>;
};

export const DEFAULT_DIR_SETTINGS: DirSettings = {
  environment: '',
  includeLocal: true,
  lastModified: {},
};

type EnvFileDetails = {
  data: Record<string, unknown>;
  lastModified?: number;
};

export class Infrastructure {
  static async safeReadEnvFile(
    filePath: string,
  ): Promise<EnvFileDetails | null> {
    try {
      const data = await Deno.readTextFile(filePath);
      const fileStats = await Deno.stat(filePath);
      const parsedData = data.split('\n').reduce((acc, line) => {
        const [key, ...value] = line.split('=');
        // if the line is empty or a comment, ignore it
        if (!line.trim() || line.trim().startsWith('#')) {
          return acc;
        }
        acc[key.trim()] = value.join('=').trim();
        return acc;
      }, {} as Record<string, unknown>);
      return {
        data: parsedData,
        lastModified: fileStats.mtime?.getTime(),
      };
    } catch (error) {
      if (error instanceof Deno.errors.NotFound) {
        return null;
      }
      throw error;
    }
  }

  static async safeWriteDotEnvFile(
    { dirPath, env, data }: {
      dirPath: string;
      env: string;
      data: Record<string, unknown>;
    },
  ): Promise<void> {
    const slug = env ? `and .env.${env} files` : 'file';
    const header =
      `# WARNING: Do not edit this file directly as it will be overwritten!
# This file is auto-generated by dot-env-to-dir-env. To update the contents of
# this file make adjustments to the .env ${slug} or adjust the
# current environment with the dot-env-to-dir-env CLI.`;

    await Deno.writeTextFile(
      `${dirPath}/.envrc`,
      `${header}\n${
        Object.entries(data)
          .map(([key, value]) => `export ${key}=${value}`)
          .join('\n')
      }`,
    );
  }

  static async getSettingsForPath(
    dirPath: string,
  ): Promise<DirSettings> {
    // Read the .dot2dirrc file if it exists to get the environment. If it does not exist,
    // use the default environment
    const dot2dirrcFile = `${dirPath}/${DOT_FILE}`;
    let fileData: string | null = null;
    try {
      fileData = await Deno.readTextFile(dot2dirrcFile);
    } catch (error) {
      if (error instanceof Deno.errors.NotFound) {
        return DEFAULT_DIR_SETTINGS;
      }
      throw error;
    }

    try {
      return Object.assign({}, DEFAULT_DIR_SETTINGS, {
        ...JSON.parse(fileData) as DirSettings,
      });
    } catch {
      return Object.assign({}, DEFAULT_DIR_SETTINGS, {
        environment: fileData,
      });
    }
  }

  static async writeSettingsForPath(
    dirPath: string,
    settings: DirSettings,
  ): Promise<void> {
    // Write the settings file
    await Deno.writeTextFile(
      `${dirPath}/${DOT_FILE}`,
      JSON.stringify(settings),
    );
  }

  static async areFilesModified(
    dirPath: string,
    files: string[],
    settings: DirSettings,
  ): Promise<boolean> {
    const results = files.map(async (fileName) => {
      const filePath = `${dirPath}/${fileName}`;
      try {
        const fileStats = await Deno.stat(filePath);
        const lastModified = settings.lastModified[fileName];
        if (lastModified === undefined || !fileStats.mtime) {
          return true;
        }
        return fileStats.mtime.getTime() > lastModified;
      } catch (err) {
        if (err instanceof Deno.errors.NotFound) {
          // When a file does not exist, we consider it un modified so that
          // upstream consumers can bypass processing the file.
          return false;
        }
        throw err;
      }
    });

    return (await Promise.all(results)).some((result) => result);
  }
}
