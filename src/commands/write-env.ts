import { Command, ArgumentValue } from '@cliffy/command';
import { DOT_FILE } from '../constants.ts';

type DirSettings = {
  environment: string;
  includeLocal: boolean;
};

function nullableBooleanType({ label, name, value }: ArgumentValue): boolean | undefined {
  if (value === 'true' || value === '1') {
    return true;
  }
  if (value === 'false' || value === '0') {
    return false;
  }
  return undefined;
}

async function safeReadEnvFile(
  filePath: string,
): Promise<Record<string, unknown> | null> {
  try {
    const data = await Deno.readTextFile(filePath);
    return data.split('\n').reduce((acc, line) => {
      const [key, ...value] = line.split('=');
      // if the line is empty or a comment, ignore it
      if (!line.trim() || line.startsWith('#')) {
        return acc;
      }
      acc[key.trim()] = value.join('=').trim();
      return acc;
    }, {} as Record<string, unknown>);
  } catch (error) {
    if (error instanceof Deno.errors.NotFound) {
      return null;
    }
    throw error;
  }
}

async function getSettingsForPath(dirPath: string): Promise<DirSettings> {
  // Read the .dot2dirrc file if it exists to get the environment. If it does not exist,
  // use the default environment
  const dot2dirrcFile = `${dirPath}/${DOT_FILE}`;
  let fileData: string | null = null;
  try {
    fileData = await Deno.readTextFile(dot2dirrcFile);
  } catch (error) {
    if (error instanceof Deno.errors.NotFound) {
      console.log(
        `No .dot2dirrc file found at ${dirPath}, using default environment`,
      );
      return {
        environment: '',
        includeLocal: true,
      };
    }
    throw error;
  }

  try {
    return JSON.parse(fileData) as DirSettings;
  } catch {
    return {
      environment: fileData,
      includeLocal: true,
    }
  }
}

export const writeEnv = new Command()
  .name('writeEnv')
  .description('Write the .envrc file')
  .type('nullableBoolean', nullableBooleanType)
  .option(
    '-d, --dir <dir:string>',
    'The directory to create or update a .envrc file. Uses the current working directory if not specified',
  )
  .option(
    '-e, --env <env:string>',
    'The environment to write to the .envrc file',
  )
  // NOTE: If we can figure out how to use -e "" and be valid that would remove the need for the baseEnv option
  //       and we can just use -e "" to indicate that we want to use the base .env file
  //       Look into the `value` callback on the above option.
  .option(
    '--base-env',
    'The environment will no longer be overlayed on top of the base .env file in the output .envrc file',
    {default: false, conflicts: ['env']},
  )
  // TODO: Make boolean | undefined
  .option(
    '--include-local <includeLocal:nullableBoolean>',
    'Includes a .env.local file when merging environment files. This file is merged last',
    {default: undefined},
  )
  .action(async ({ dir, env, baseEnv, includeLocal }) => {
    const workingDir = dir || Deno.cwd();
    const workingSettings = await getSettingsForPath(workingDir);
    if (env) {
      workingSettings.environment = env;
    } else if (baseEnv) {
      workingSettings.environment = '';
    }

    if (includeLocal !== undefined) {
      workingSettings.includeLocal = includeLocal;
    }

    // Write the settings file
    await Deno.writeTextFile(
      `${workingDir}/${DOT_FILE}`,
      JSON.stringify(workingSettings),
    );

    // Read the .env file if it exists, if it does not exist, exit gracefully
    const envFile = `${workingDir}/.env`;
    const baseData = await safeReadEnvFile(envFile);
    if (!baseData) {
      console.log(`No .env file found at ${envFile}`);
      return;
    }

    // Read the .env.${env} file if it exists, if it does not exist, continue
    const envData = await safeReadEnvFile(`${workingDir}/.env.${workingSettings.environment}`);
    if (envData) {
      // Merge the base and env data
      Object.assign(baseData, envData);
    }

    // Read the .env.local file if it exists, if it does not exist, continue
    if (workingSettings.includeLocal) {
      const localData = await safeReadEnvFile(`${workingDir}/.env.local`);
      if (localData) {
        // Merge the base and env local data
        Object.assign(baseData, localData);
      }
    }

    // Write the .envrc file
    const slug = workingSettings.environment ? `and .env.${workingSettings.environment} files` : 'file';
    const header =
      `# WARNING: Do not edit this file directly as it will be overwritten!
# This file is auto-generated by dot-env-to-dir-env. To update the contents of
# this file make adjustments to the .env ${slug} or adjust the
# current environment with the dot-env-to-dir-env CLI.`;
    await Deno.writeTextFile(
      `${workingDir}/.envrc`,
      `${header}\n${
        Object.entries(baseData)
          .map(([key, value]) => `export ${key}=${value}`)
          .join('\n')
      }`,
    );
  });
