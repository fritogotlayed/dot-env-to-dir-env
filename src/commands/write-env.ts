import { Command } from '@cliffy/command';
import { DOT_FILE } from '../constants.ts';

async function safeReadEnvFile(
  filePath: string,
): Promise<Record<string, unknown> | null> {
  try {
    const data = await Deno.readTextFile(filePath);
    return data.split('\n').reduce((acc, line) => {
      const [key, ...value] = line.split('=');
      // if the line is empty or a comment, ignore it
      if (!line.trim() || line.startsWith('#')) {
        return acc;
      }
      acc[key.trim()] = value.join('=').trim();
      return acc;
    }, {} as Record<string, unknown>);
  } catch (error) {
    if (error instanceof Deno.errors.NotFound) {
      return null;
    }
    throw error;
  }
}

async function getEnvForPath(dirPath: string): Promise<string> {
  // Read the .dot2dirrc file if it exists to get the environment. If it does not exist,
  // use the default environment
  const dot2dirrcFile = `${dirPath}/${DOT_FILE}`;
  let fileData: string | null = null;
  try {
    fileData = await Deno.readTextFile(dot2dirrcFile);
  } catch (error) {
    if (error instanceof Deno.errors.NotFound) {
      console.log(
        `No .dot2dirrc file found at ${dirPath}, using default environment`,
      );
      return '';
    }
    throw error;
  }
  return fileData;
}

export const writeEnv = new Command()
  .name('writeEnv')
  .description('Write the .envrc file')
  .option(
    '-d, --dir <dir:string>',
    'The directory to create or update a .envrc file',
  )
  .option(
    '-e, --env <env:string>',
    'The environment to write to the .envrc file',
  )
  // NOTE: If we can figure out how to use -e "" and be valid that would remove the need for the baseEnv option
  //       and we can just use -e "" to indicate that we want to use the base .env file
  //       Look into the `value` callback on the above option.
  .option(
    '--base-env',
    'The environment will no longer be overlayed on top of the base .env file in the output .envrc file',
    {default: false}
  )
  .action(async ({ dir, env, baseEnv }) => {
    const workingDir = dir || Deno.cwd();
    let targetEnv = env || '';
    if (env) {
      console.log(
        `Updating .envrc file ${env ? 'for environment ' : ''}${
          env ?? 'to base'
        }`,
      );

      // Write the settings file
      await Deno.writeTextFile(
        `${workingDir}/${DOT_FILE}`,
        `${env ?? ''}`,
      );
    } else if (baseEnv) {
      // Write the settings file
      await Deno.writeTextFile(
        `${workingDir}/${DOT_FILE}`,
        '',
      );
    } else {
      targetEnv = await getEnvForPath(workingDir);
    }

    // Read the .env file if it exists, if it does not exist, exit gracefully
    const envFile = `${workingDir}/.env`;
    const baseData = await safeReadEnvFile(envFile);
    if (!baseData) {
      console.log(`No .env file found at ${envFile}`);
      return;
    }

    // Read the .env.${env} file if it exists, if it does not exist, continue
    const envData = await safeReadEnvFile(`${workingDir}/.env.${targetEnv}`);
    if (envData) {
      // Merge the base and env data
      Object.assign(baseData, envData);
    }

    // Write the .envrc file
    const slug = targetEnv ? `and .env.${targetEnv} files` : 'file';
    const header =
      `# WARNING: Do not edit this file directly as it will be overwritten!
# This file is auto-generated by dot-env-to-dir-env. To update the contents of
# this file make adjustments to the .env ${slug} or adjust the
# current environment with the dot-env-to-dir-env CLI.`;
    await Deno.writeTextFile(
      `${workingDir}/.envrc`,
      `${header}\n${
        Object.entries(baseData)
          .map(([key, value]) => `export ${key}=${value}`)
          .join('\n')
      }`,
    );
  });
