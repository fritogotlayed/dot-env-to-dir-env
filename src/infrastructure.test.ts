import { describe, it } from '@std/testing/bdd';
import { expect } from '@std/expect';
import { assertSpyCall, returnsNext, stub } from '@std/testing/mock';
import { Infrastructure } from './infrastructure.ts';

describe('infrastructure', () => {
  describe('safeReadEnvFile', () => {
    it('should return null if the file does not exist', async () => {
      // Arrange
      const readTextFileStub = stub(
        Deno,
        'readTextFile',
        returnsNext([
          Promise.reject(new Deno.errors.NotFound('File not found')),
        ]),
      );

      try {
        // Act
        const result = await Infrastructure.safeReadEnvFile('.');

        // Assert
        expect(result).toBeNull();
      } finally {
        readTextFileStub.restore();
      }
    });

    it('should return key value pairs from a file', async () => {
      // Arrange
      const now = new Date();
      const readTextFileStub = stub(
        Deno,
        'readTextFile',
        returnsNext([
          Promise.resolve(`
            # This is a comment
            KEY1=value1
            KEY2=value2
            KEY3=value3
          `),
        ]),
      );
      const statStub = stub(
        Deno,
        'stat',
        returnsNext([
          Promise.resolve({
            mtime: now,
          } as Deno.FileInfo),
        ]),
      );

      try {
        // Act
        const result = await Infrastructure.safeReadEnvFile('.');

        // Assert
        expect(result).toEqual({
          data: {
            KEY1: 'value1',
            KEY2: 'value2',
            KEY3: 'value3',
          },
          lastModified: now.getTime(),
        });
      } finally {
        readTextFileStub.restore();
        statStub.restore();
      }
    });
  });

  describe('safeWriteDotEnvFile', () => {
    it('with no env should call deno write text file with appropriate arguments', async () => {
      // Arrange
      const writeTextFileStub = stub(
        Deno,
        'writeTextFile',
        returnsNext([Promise.resolve()]),
      );

      try {
        // Act
        await Infrastructure.safeWriteDotEnvFile({
          dirPath: '.',
          env: '',
          data: {
            KEY1: 'value1',
            KEY2: 'value2',
            KEY3: 'value3',
          },
        });

        // Assert
        const expectedBody =
          `# WARNING: Do not edit this file directly as it will be overwritten!
# This file is auto-generated by dot-env-to-dir-env. To update the contents of
# this file make adjustments to the .env file or adjust the
# current environment with the dot-env-to-dir-env CLI.
export KEY1=value1
export KEY2=value2
export KEY3=value3`;
        assertSpyCall(
          writeTextFileStub,
          0,
          { args: ['./.envrc', expectedBody] },
        );
      } finally {
        writeTextFileStub.restore();
      }
    });

    it('with env should call deno write text file with appropriate arguments', async () => {
      // Arrange
      const writeTextFileStub = stub(
        Deno,
        'writeTextFile',
        returnsNext([Promise.resolve()]),
      );

      try {
        // Act
        await Infrastructure.safeWriteDotEnvFile({
          dirPath: '.',
          env: 'foo',
          data: {
            KEY1: 'value1',
            KEY2: 'value2',
            KEY3: 'value3',
          },
        });

        // Assert
        const expectedBody =
          `# WARNING: Do not edit this file directly as it will be overwritten!
# This file is auto-generated by dot-env-to-dir-env. To update the contents of
# this file make adjustments to the .env and .env.foo files or adjust the
# current environment with the dot-env-to-dir-env CLI.
export KEY1=value1
export KEY2=value2
export KEY3=value3`;
        assertSpyCall(
          writeTextFileStub,
          0,
          { args: ['./.envrc', expectedBody] },
        );
      } finally {
        writeTextFileStub.restore();
      }
    });
  });

  describe('getSettingsForPath', () => {
    it('should return defaults if the file does not exist', async () => {
      // Arrange
      const readTextFileStub = stub(
        Deno,
        'readTextFile',
        returnsNext([
          Promise.reject(new Deno.errors.NotFound('File not found')),
        ]),
      );

      try {
        // Act
        const result = await Infrastructure.getSettingsForPath('.');

        // Assert
        expect(result).toEqual({
          environment: '',
          includeLocal: true,
          lastModified: {},
        });
      } finally {
        readTextFileStub.restore();
      }
    });

    it('should return parsed settings from a file', async () => {
      // Arrange
      const readTextFileStub = stub(
        Deno,
        'readTextFile',
        returnsNext([
          Promise.resolve(JSON.stringify({
            environment: 'foo',
            includeLocal: true,
          })),
        ]),
      );

      try {
        // Act
        const result = await Infrastructure.getSettingsForPath('.');

        // Assert
        expect(result).toEqual({
          environment: 'foo',
          includeLocal: true,
          lastModified: {},
        });
      } finally {
        readTextFileStub.restore();
      }
    });

    it('should handle previous settings file format gracefully', async () => {
      // Arrange
      const readTextFileStub = stub(
        Deno,
        'readTextFile',
        returnsNext([
          Promise.resolve('bar'),
        ]),
      );

      try {
        // Act
        const result = await Infrastructure.getSettingsForPath('.');

        // Assert
        expect(result).toEqual({
          environment: 'bar',
          includeLocal: true,
          lastModified: {},
        });
      } finally {
        readTextFileStub.restore();
      }
    });
  });

  describe('writeSettingsForPath', () => {
    it('should call deno write text file with appropriate arguments', async () => {
      // Arrange
      const writeTextFileStub = stub(
        Deno,
        'writeTextFile',
        returnsNext([Promise.resolve()]),
      );
      const settings = {
        environment: 'foo',
        includeLocal: false,
        lastModified: {},
      };

      try {
        // Act
        await Infrastructure.writeSettingsForPath('.', settings);

        // Assert
        assertSpyCall(
          writeTextFileStub,
          0,
          { args: ['./.dot2dirrc', JSON.stringify(settings)] },
        );
      } finally {
        writeTextFileStub.restore();
      }
    });
  });

  describe('areFilesModified', () => {
    it('should return true if the files have been updated since the last settings save', async () => {
      // Arrange
      const statStub = stub(
        Deno,
        'stat',
        returnsNext([
          // foo
          Promise.resolve({
            mtime: new Date('2022-01-01T00:00:00.000Z'),
          } as Deno.FileInfo),
          // bar
          Promise.resolve({
            mtime: new Date('2022-01-01T00:00:01.000Z'),
          } as Deno.FileInfo),
        ]),
      );

      try {
        // Act
        const result = await Infrastructure.areFilesModified('.', [
          'foo',
          'bar',
        ], {
          environment: 'foo',
          includeLocal: true,
          lastModified: {
            foo: new Date('2022-01-01T00:00:00.000Z').getTime(),
            bar: new Date('2022-01-01T00:00:00.000Z').getTime(),
          },
        });

        // Assert
        expect(result).toBe(true);
      } finally {
        statStub.restore();
      }
    });

    it('should return true if the files are not in the last settings save', async () => {
      // Arrange
      const statStub = stub(
        Deno,
        'stat',
        returnsNext([
          // foo
          Promise.resolve({
            mtime: new Date('2022-01-01T00:00:00.000Z'),
          } as Deno.FileInfo),
          // bar
          Promise.resolve({
            mtime: new Date('2022-01-01T00:00:01.000Z'),
          } as Deno.FileInfo),
        ]),
      );

      try {
        // Act
        const result = await Infrastructure.areFilesModified('.', [
          'foo',
          'bar',
        ], {
          environment: 'foo',
          includeLocal: true,
          lastModified: {},
        });

        // Assert
        expect(result).toBe(true);
      } finally {
        statStub.restore();
      }
    });

    it('should return false if the files have not been updated since the last settings save', async () => {
      // Arrange
      const statStub = stub(
        Deno,
        'stat',
        returnsNext([
          // foo
          Promise.resolve({
            mtime: new Date('2022-01-01T00:00:00.000Z'),
          } as Deno.FileInfo),
          // bar
          Promise.resolve({
            mtime: new Date('2022-01-01T00:00:00.000Z'),
          } as Deno.FileInfo),
        ]),
      );

      try {
        // Act
        const result = await Infrastructure.areFilesModified('.', [
          'foo',
          'bar',
        ], {
          environment: 'foo',
          includeLocal: true,
          lastModified: {
            foo: new Date('2022-01-01T00:00:00.000Z').getTime(),
            bar: new Date('2022-01-01T00:00:00.000Z').getTime(),
          },
        });

        // Assert
        expect(result).toBe(false);
      } finally {
        statStub.restore();
      }
    });
  });
});
